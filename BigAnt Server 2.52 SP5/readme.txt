xp sp2 - BigAnt 2.52 SP5 - net user evil pass cacat

1. run exp1.py -> crash 004764BF and AV (Access Violation at 00FD0000)
2. View -> SEH Chains -> We have overwrite at 00FCFD7C (41414141)
3. POP, POP, RETN methods might be used but we must take into account SafeSEH protection

	Use a overwrite address from a module that was not compiled with the /SafeSEH ON or IMAGE_DLLCHARACTERISTICS_NO_SEH options. Third party modules, and main executables are usually compiled without these options, however addresses from the main executables are often unsuitable because they contain a leading zero \x00 character which often break overflows.
	Use an instruction from a predictable spot in memory, marked executable, that sits outside the areas of loaded modules considered in scope for the SEH verification tests.
	Use an address from the heap.
	Use a registered handler address for the SEH overwrite. For most vulnerabilities this won't create a usable exploit.
	On Windows Server 2003 before SP1, it was possible to use SEH overwrite addresses in modules like ATL.dll, because the registered handlers list was not checked by the exception handler. On Windows XP SP2 and WIndows Server SP1 and up this method is not viable.

	OllySSEH
4. We must find a DLL that doesnt have SEH on (we should look for uncommon DLLs such as the app DLLs and others)

5. we test vbajet32.dll (download from machine into the main machine)

6. msfpescan -i vbajet32.dll | grep SEHandler (look for any SafeSEH on) -> nothing found -> looks great

7. msfpescan -i vbajet32.dll | grep DllCharacteristics ( we look for anything beside 0 at the 4th bit from right to left, if 0 is great)

8. Going back into Olly we look for POP r32, POP r32, RETN in SEQUENCE Commands -> jackpot at 0x0F9A196A -> no \0, cr, lf or \x00\x0a\x0d

9. we build pattern_create.rb 2500 and we run exp2.py -> 0x013CFD7C -> 42326742 -> pattern_offset.rb at 966

10. we run exp3.py and we got 41414141 after we look at SEH Chains

11. we build exp4.py and we set the POP POP RETN adress (step 8) but using endian order of x86 processors

12. we set a breakpoint at POP POP RETN adress and run exp4.py -> SHIFT+F9 -> F7 F7 F7 -> we get into \xcc\xcc\xcc\xcc (so we have 4 bytes of memory) -> 4 byte corner -> Follow in dump 

(bellow)
 We get 0x012CFD84 start and 0x012CFFFF end 0x012CFFFF - 0x012CFD84 = 0x27B or 635 bytes

OR
(above)
0x012CFD7B - 0x012CF9BA = 0x3C1 or 961 bytes

13. edit exp4.py 

JMP SHORT 4 bytes + 2 NOPS
\xeb\xXX where XX is number of bytes to jump
in our case is \xeb\x06

and we add our shell code with some nops around it


msfpayload windows/exec CMD=calc.exe R | msfencode -a x86 -b '\x00\x0a\x0d' -s 619 -t c

if we try anything else will see a crash here, thats because we have bad chars

using generatecodes.pl and divide et impera we keep adding line by line and splitting till we find the bad char and we rebuild the shellcode, in this case \x20 is bad

we can use comparememory.pl memory.txt shellcode.txt to compare what is in memory () and the original shellcode and we \x25 as be bad

